/*
 * Copyright (c) 2021. Lorem ipsum dolor sit amet, consectetur adipiscing elit.
 * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.
 * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.
 * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.
 * Vestibulum commodo. Ut rhoncus gravida arcu.
 */

package edu.lu.uni.serval.renamed.methods;/*
 *   @author Michael
 *   @create 2021/1/7
 */

import edu.lu.uni.serval.utils.FileHelper;

import java.io.IOException;
import java.util.*;

public class ICSE2020_evaluate {

    public static void main(String [] args) throws IOException {
        // inconsistent evaluation
//        String basePath1 = "/home1/michael/BadMethodName/debug-method-name-master/Data/TestData/";
//        String basePath1 = "/home1/michael/BadMethodName/Training/TestingData/InconsistentMethods/";

//        String basePath1 = "/home1/michael/BadMethodName/Output_TestingRepos/InconsistentMethods/ICSE2020TestData/Tuning";
//        String basePath1 = "/home1/michael/BadMethodName/Output_TestingRepos/InconsistentMethods/ICSE2020TestData/Balanced/";
        String basePath1 = "/home1/michael/BadMethodName/Output_TestingRepos/InconsistentMethods/ICSE2020TestData/RealRatio/";
//        String basePath1 = "/home1/michael/BadMethodName/Output_TestingRepos/InconsistentMethods/ICSE2020TestData/NewBalancedData/Cross-Method/CORPUS+CON/";
//        String basePath1 = "/home1/michael/BadMethodName/Output_TestingRepos/InconsistentMethods/ICSE2020TestData/NewBalancedData/Cross-Method/CORPUS+INCON/";
//        String basePath1 = "/home1/michael/BadMethodName/Training/TestingData/Cross-Method/FinalVersion/icse2020/Inconsistent/";
//        String basePath1 = "/home1/michael/BadMethodName/Training/TestingData/Cross-Method/FinalVersion/icse2020/Consistent/";
//        String basePath1 = "/home1/michael/BadMethodName/Output_TestingRepos/InconsistentMethods/ICSE2020TestData/NewBalancedData/new2/";
//        String trainingPath = "/home1/michael/BadMethodName/Training/TrainingData/";

//        String trainingPath = "/home1/michael/ICSE2020/ICSE2020_Code/data/";
//        String trainingPath = "/home1/michael/BadMethodName/debug-method-name-master/Data/TrainingData/TrainingMethodInfo.txt/";

//        detailedInfoOfGeneration(basePath1);
        evaluate(basePath1);
//        evaluate_1(basePath1);

//        for(double i = 1.0; i>0;i = i -0.1){
//            if(i==0.49){
//        double i =0.99;
//                String inconsistentResult = evaluate4adjustment(basePath1,"inconsistent",i);
//                String consistentResult = evaluate4adjustment(basePath1,"consistent",i);
//
//                int TP = Integer.parseInt(inconsistentResult.split(",")[0]);
//                int TN = Integer.parseInt(consistentResult.split(",")[0]);
//                int FN = Integer.parseInt(inconsistentResult.split(",")[1]);
//                int FP = Integer.parseInt(consistentResult.split(",")[1]);
//
////            System.out.println(TP);
////            System.out.println(TN);
////            System.out.println(FN);
////            System.out.println(FP);
////                System.out.println(i+"--------------------------------------------------------");
////                System.out.print(i+":");
//                IREvaluation.evaluate(TP,TN,FN,FP);
//            }

//        }




//        ifTestNameTokenCouldBeFoundInTraining(basePath1,trainingPath);
//        ifTestNameTokenCouldBeFoundInTrainingContext(basePath1,trainingPath);

//        evaluate_checkIfMatters(basePath);
//        shortMethodNamesEva(basePath1);
//        shortMethodNamesCorrectEva(basePath1);



        // get consistent methods which are predicted as inconsistent and are with less than 3 tokens
//        getMethodsOfLT3Tokens(basePath1);

        // if only take care of the first token. // Deprecated
//        judgeWithFirstToken(basePath1);
        
//        ifTokenCouldBeFoundInContext(basePath1);

//        ifTraingTokenCouldBeFoundInContext(trainingPath);

        //get all unique names which are generated by MNIRE
//        List<Map.Entry<String,Integer>> uniqueNamesList = getAllUniqueNames(basePath1);
//
//        List<Map.Entry<String,Integer>> totalNamesList = shortMethodNamesTotalEva(basePath1);
//
//        for(Map.Entry<String,Integer> entry:uniqueNamesList){
//            String methodName = entry.getKey();
//            int frequencyInCorrect = entry.getValue();
//            int frequencyInTotal = getSpecificValue(totalNamesList,methodName).getValue();
//            System.out.println(methodName+":"+frequencyInCorrect+":"+frequencyInTotal);
//        }

//        List<Map.Entry<String,Integer>> totalNamesList = shortMethodNamesTotalEva(basePath1);

    }
    private static Map.Entry<String,Integer> getSpecificValue(List<Map.Entry<String,Integer>> list, String key){
        for(Map.Entry<String,Integer> entry:list){
            if(entry.getKey().equals(key)){
                return entry;
            }
        }
        return null;
    }
    private static void ifTestNameTokenCouldBeFoundInTrainingContext(String basePath1, String trainingPath) throws IOException {
//        String trainingNameTokens = trainingPath + "parsedMethodContextTokens_withOverride.txt";
        String trainingNameTokens = trainingPath + "filter_context_tokens.txt";
//        String trainingNameTokens = trainingPath + "parsedMethodNameTokens_withOverride.txt";
        String TestingNameTokens = basePath1 + "TestMethodNames.txt";
//        String TestingNameTokens = basePath1 + "consistentMethodNames.txt";
        ArrayList<String> TrainingNameList = ParserMethodNameMain.getLines(trainingNameTokens);
        ArrayList<String> TestingNameList = ParserMethodNameMain.getLines(TestingNameTokens);
//        StringBuilder nameTokenCouldBeFoundInContext = new StringBuilder();
//        StringBuilder contextTokenCouldBeFoundInContext = new StringBuilder();
//        StringBuilder nameTokenCouldNotAllBeFoundInContext = new StringBuilder();
//        StringBuilder contextTokenCouldNotAllBeFoundInContext = new StringBuilder();
//        HashSet<String> trainingTokens = new HashSet<>();
//        HashSet<String> testingTokens = new HashSet<>();
        int cnt = 0;
        for(int i=0; i< TestingNameList.size();i++){
//            boolean mark = false;
            String testingName = TestingNameList.get(i);
            for(String trainingLine:TrainingNameList){
                if(trainingLine.contains(testingName.trim())){
                    System.out.println(testingName+":"+trainingLine);
                    cnt++;
                    break;
                }
            }

        }
//        for(int i=0; i< TrainingNameList.size();i++){
//            String trainingName = TrainingNameList.get(i);
//            List<String> trainingNameTokensList = Arrays.asList(trainingName.split(" "));
//            trainingTokens.addAll(trainingNameTokensList);
//        }
//        System.out.println(testingTokens.size());
//        testingTokens.retainAll(trainingTokens);
//        System.out.println(trainingTokens.size());
//        System.out.println(testingTokens.size());
        System.out.println(cnt);
        System.out.println(TestingNameList.size());

    }


    private static void ifTestNameTokenCouldBeFoundInTraining(String basePath1,String trainingPath) throws IOException {
        String trainingNameTokens = trainingPath + "methodNames.txt";
//        String trainingNameTokens = trainingPath + "parsedMethodNameTokens_withOverride.txt";
        String TestingNameTokens = basePath1 + "TestMethodNames.txt";
        ArrayList<String> TrainingNameList = ParserMethodNameMain.getLines(trainingNameTokens);
        ArrayList<String> TestingNameList = ParserMethodNameMain.getLines(TestingNameTokens);
//        StringBuilder nameTokenCouldBeFoundInContext = new StringBuilder();
//        StringBuilder contextTokenCouldBeFoundInContext = new StringBuilder();
//        StringBuilder nameTokenCouldNotAllBeFoundInContext = new StringBuilder();
//        StringBuilder contextTokenCouldNotAllBeFoundInContext = new StringBuilder();
        HashSet<String> trainingTokens = new HashSet<>();
        HashSet<String> testingTokens = new HashSet<>();
//        int cnt = 0;
        for(int i=0; i< TestingNameList.size();i++){
//            boolean mark = false;
            String testingName = TestingNameList.get(i);
            List<String> testingNameTokensList = Arrays.asList(testingName.split(" "));
            testingTokens.addAll(testingNameTokensList);
        }
        for(int i=0; i< TrainingNameList.size();i++){
            String trainingName = TrainingNameList.get(i);
            List<String> trainingNameTokensList = Arrays.asList(trainingName.split(" "));
            trainingTokens.addAll(trainingNameTokensList);
        }
        System.out.println(testingTokens.size());
        testingTokens.retainAll(trainingTokens);
        System.out.println(trainingTokens.size());
        System.out.println(testingTokens.size());

//        System.out.println(cnt);
    }



    private static List<Map.Entry<String,Integer>> getAllUniqueNames(String basePath1) throws IOException {
//        String consistentSuccessFile = basePath1 + "ConsistentFailGetSetMethodsAnalysisReport.txt";
        String consistentSuccessFile = basePath1 + "ConsistentSuccessGetSetMethodsAnalysisReport.txt";
//        String consistentSuccessFile = basePath1 + "allGetSetResultsMethods.txt";
        ArrayList<String> csList = ParserMethodNameMain.getLines(consistentSuccessFile);
        HashMap<String,Integer> methodNameTokensNumberAndNumber = new HashMap<>();
        for(String s:csList){
            String name = s.split(":")[0];
            if(methodNameTokensNumberAndNumber.get(name)==null){
                methodNameTokensNumberAndNumber.put(name,1);
            }
            else{
                int num = methodNameTokensNumberAndNumber.get(name);
                methodNameTokensNumberAndNumber.put(name,num+1);
            }
        }
        System.out.println(methodNameTokensNumberAndNumber.keySet().size());
        List<Map.Entry<String,Integer>> list =  Utils.sortMap(methodNameTokensNumberAndNumber);
//        for(Map.Entry<String,Integer> s:list){
//            System.out.println(s.getKey()+":"+s.getValue());
//        }
        System.out.println(list);
//        System.out.println(list.subList(0,100));
        return list;
    }
    private static void detailedInfoOfGeneration(String basePath) throws IOException {
//        String methodNameTokens = basePath + "MethodNameTokens.txt";
//        String methodNameTokens = basePath + "parsedMethodNameTokens.txt";
        String methodNameTokens = basePath + "TestMethodNames.txt";
//        String methodNameTokens = basePath + "TestMethodNames_RepairedVersion.txt";
//        String methodNameTokens = basePath + "allGeneratedCorrect.txt";
//        String methodNameTokens = basePath + "TrainingData\\ParsedMethodNameTokens_1.txt";
        String resultPath = basePath + "predictedNames.txt";
//        String resultPath = basePath + "allResult_TrainingDataAllTokens.txt";
        ArrayList<String> nameTokens = ParserMethodNameMain.getLines(methodNameTokens);
        ArrayList<String> resultTokens = ParserMethodNameMain.getLines(resultPath);
//        System.out.println(nameTokens.size());
        int cnt1=0,cnt2=0,cnt3=0,cnt4=0,cnt5=0,cnt6=0;
        for(int i= 0;i<resultTokens.size();i++){
            String resultToken = resultTokens.get(i);
            String nameToken = nameTokens.get(i);
            int length = nameToken.split(" ").length;
            ArrayList<String> nameTokensList = new ArrayList<>(Arrays.asList(nameToken.split(" ")));
            ArrayList<String> resultTokensList = new ArrayList<>(Arrays.asList(resultToken.split(" ")));
            nameTokensList.retainAll(resultTokensList);
//            if(length==13){
            if(length>=10){
                cnt1++;
                if(nameTokensList.size()==0){
                    cnt2++;
                }
                else if(nameTokensList.size()==1){
                    cnt3++;
                }
                else if(nameTokensList.size()==2){
                    cnt4++;
                }
                else if(nameTokensList.size()>=3){
                    cnt5++;
                }
                else{
                    cnt6++;
                }
            }
        }
        System.out.println(cnt1);
        System.out.println();
        System.out.println(cnt5);
        System.out.println(cnt4);
        System.out.println(cnt3);
        System.out.println(cnt2);



        System.out.println();
        System.out.println(cnt6);
    }

    private static void ifTraingTokenCouldBeFoundInContext(String trainingPath) throws IOException {
        String nameTokens = trainingPath + "parsedMethodNameTokens.txt";
        String contextTokens = trainingPath + "parsedMethodContextTokens.txt";
        ArrayList<String> correctNameList = ParserMethodNameMain.getLines(nameTokens);
        ArrayList<String> correctContextList = ParserMethodNameMain.getLines(contextTokens);
        StringBuilder nameTokenCouldBeFoundInContext = new StringBuilder();
        StringBuilder contextTokenCouldBeFoundInContext = new StringBuilder();
        StringBuilder nameTokenCouldNotAllBeFoundInContext = new StringBuilder();
        StringBuilder contextTokenCouldNotAllBeFoundInContext = new StringBuilder();
        for(int i=0; i< correctNameList.size();i++){
            boolean mark = false;
            String correctName = correctNameList.get(i);
            String correctContext = correctContextList.get(i);

            List<String> correctNameTokens = Arrays.asList(correctName.split(" "));
            List<String> correctContextTokens = Arrays.asList(correctContext.split(" "));

            for(String s:correctNameTokens){
                if(!correctContextTokens.contains(s)){
                    mark = true;
                }
            }
            if(!mark){
                nameTokenCouldBeFoundInContext.append(correctName+"\n");
                contextTokenCouldBeFoundInContext.append(correctContext+"\n");
            }
            else{
                nameTokenCouldNotAllBeFoundInContext.append(correctName+"\n");
                contextTokenCouldNotAllBeFoundInContext.append(correctContext+"\n");
            }

        }
        FileHelper.outputToFile(trainingPath + "nameTokenCouldBeFoundInContext.txt",nameTokenCouldBeFoundInContext,false);
        FileHelper.outputToFile(trainingPath + "contextTokenCouldBeFoundInContext.txt",contextTokenCouldBeFoundInContext,false);

        FileHelper.outputToFile(trainingPath + "nameTokenCouldNotAllBeFoundInContext.txt",nameTokenCouldNotAllBeFoundInContext,false);
        FileHelper.outputToFile(trainingPath + "contextTokenCouldNotAllBeFoundInContext.txt",contextTokenCouldNotAllBeFoundInContext,false);

    }

    private static void ifTokenCouldBeFoundInContext(String basePath) throws IOException {
//        String correctNameFile = basePath + "correct.txt";
//        String correctContextFile = basePath + "correctContext.txt";
        String correctNameFile = basePath + "MethodsOfLT3FalseNameTokens.txt";
        String correctContextFile = basePath + "MethodsOfLT3FalseContextTokens.txt";
        ArrayList<String> correctNameList = ParserMethodNameMain.getLines(correctNameFile);
        ArrayList<String> correctContextList = ParserMethodNameMain.getLines(correctContextFile);
        StringBuilder nameTokenCouldBeFoundInContext = new StringBuilder();
        StringBuilder contextTokenCouldBeFoundInContext = new StringBuilder();
        StringBuilder nameTokenCouldNotAllBeFoundInContext = new StringBuilder();
        StringBuilder contextTokenCouldNotAllBeFoundInContext = new StringBuilder();
        for(int i=0; i< correctNameList.size();i++){
            boolean mark = false;
            String correctName = correctNameList.get(i).split(":")[1];
            String correctContext = correctContextList.get(i);

            List<String> correctNameTokens = Arrays.asList(correctName.split(" "));
            List<String> correctContextTokens = Arrays.asList(correctContext.split(" "));

            for(String s:correctNameTokens){
                if(!correctContextTokens.contains(s)){
                    mark = true;
                }
            }
            if(!mark){
                nameTokenCouldBeFoundInContext.append(correctName+"\n");
                contextTokenCouldBeFoundInContext.append(correctContext+"\n");
            }
            else{
                nameTokenCouldNotAllBeFoundInContext.append(correctName+"\n");
                contextTokenCouldNotAllBeFoundInContext.append(correctContext+"\n");
            }


        }
//        FileHelper.outputToFile(basePath + "nameTokenCouldBeFoundInContext_false.txt",nameTokenCouldBeFoundInContext,false);
//        FileHelper.outputToFile(basePath + "contextTokenCouldBeFoundInContext_false.txt",contextTokenCouldBeFoundInContext,false);

        FileHelper.outputToFile(basePath + "nameTokenCouldNotAllBeFoundInContext_false.txt",nameTokenCouldNotAllBeFoundInContext,false);
        FileHelper.outputToFile(basePath + "contextTokenCouldNotAllBeFoundInContext_false.txt",contextTokenCouldNotAllBeFoundInContext,false);
    }

    private static void judgeWithFirstToken(String basePath1) throws IOException {
        String falseFile = basePath1 + "MethodsOfLT3Tokens.txt";
        ArrayList<String> falseList = ParserMethodNameMain.getLines(falseFile);
        StringBuilder sb = new StringBuilder();
        for(String s:falseList){
            String result = s.split(":")[0];
            String testMethod = s.split(":")[1];
            String firstTokenOfResult = result.split(" ")[0];
            String firstTokenOftestMethod = testMethod.split(" ")[0];
            if(firstTokenOfResult.equals(firstTokenOftestMethod)){
                sb.append(s+"\n");
            }
        }
        FileHelper.outputToFile(basePath1 + "JudgeWithFirstToken.txt",sb, false);
    }

    private static void getMethodsOfLT3Tokens(String basePath1) throws IOException {
        String falseFile = basePath1 + "false.txt";
        String falseContextFile = basePath1 + "falseContext.txt";
        ArrayList<String> falseList = ParserMethodNameMain.getLines(falseFile);
        ArrayList<String> falseContextList = ParserMethodNameMain.getLines(falseContextFile);
        StringBuilder MethodsOfLT3FalseNameTokens = new StringBuilder();
        StringBuilder MethodsOfLT3FalseContextTokens = new StringBuilder();
        int index = 0;
        for(String s:falseList){
            String [] splitArray = s.split(":")[1].split(" ");
            if(splitArray.length>3){
            }
            else{
                MethodsOfLT3FalseNameTokens.append(s+"\n");
                MethodsOfLT3FalseContextTokens.append(falseContextList.get(index)+"\n");
            }
            index++;
        }
        FileHelper.outputToFile(basePath1 + "MethodsOfLT3FalseNameTokens.txt",MethodsOfLT3FalseNameTokens, false);
        FileHelper.outputToFile(basePath1 + "MethodsOfLT3FalseContextTokens.txt",MethodsOfLT3FalseContextTokens, false);
    }


    private static List<Map.Entry<String,Integer>> shortMethodNamesTotalEva(String basePath) throws IOException {
        String methodNameTokens = basePath + "parsedMethodNameTokens.txt";
        ArrayList<String> lines = ParserMethodNameMain.getLines(methodNameTokens);
        System.out.println(lines.size());
        HashMap<String,Integer> methodNameTokensNumberAndNumber = new HashMap<>();
        for(String line:lines){
            String name = line;
            if(methodNameTokensNumberAndNumber.get(name)==null){
                methodNameTokensNumberAndNumber.put(name,1);
            }
            else{
                int num = methodNameTokensNumberAndNumber.get(name);
                methodNameTokensNumberAndNumber.put(name,num+1);
            }
        }
        System.out.println(methodNameTokensNumberAndNumber.keySet().size());
        List<Map.Entry<String,Integer>>list =  Utils.sortMap(methodNameTokensNumberAndNumber);
        System.out.println(list.subList(0,100));
        return list;
    }

    private static List<Map.Entry<String,Integer>> shortMethodNamesTotalNameCorrectEva(String basePath,String fileName) throws IOException {
//        String methodNameTokens = basePath + "correct.txt";
//        String methodNameTokens = basePath + "false.txt";
        String methodNameTokens = basePath + fileName;
        ArrayList<String> lines = ParserMethodNameMain.getLines(methodNameTokens);
        System.out.println(lines.size());
        HashMap<String,Integer> methodNameTokensNumberAndNumber = new HashMap<>();
        for(String line:lines){
            String name = line.split(":")[0];
            if(methodNameTokensNumberAndNumber.get(name)==null){
                methodNameTokensNumberAndNumber.put(name,1);
            }
            else{
                int num = methodNameTokensNumberAndNumber.get(name);
                methodNameTokensNumberAndNumber.put(name,num+1);
            }
        }
        System.out.println(methodNameTokensNumberAndNumber.keySet().size());
        List<Map.Entry<String,Integer>>list =  Utils.sortMap(methodNameTokensNumberAndNumber);
//        for(Map.Entry<String,Integer> s:list){
//            System.out.println(s.getKey()+":"+s.getValue());
//        }
        System.out.println(list.subList(0,100));
        return list;
    }

    private static void shortMethodNamesCorrectEva(String basePath) throws IOException {
        String methodNameTokens = basePath + "correct.txt";
//        String methodNameTokens = basePath + "false.txt";
//        String methodNameTokens = basePath + "parsedMethodNameTokens_unique.txt";
//        String methodNameTokens = basePath + "result.txt";
        ArrayList<String> lines = ParserMethodNameMain.getLines(methodNameTokens);
        System.out.println(lines.size());
        HashMap<Integer,Integer> methodNameTokensNumberAndNumber = new HashMap<>();
        for(String line:lines){
            String [] splitArray = line.split(":")[0].split(" ");
            int size = splitArray.length;
            if(methodNameTokensNumberAndNumber.get(size)==null){
                methodNameTokensNumberAndNumber.put(size,1);
            }
            else{
                int num = methodNameTokensNumberAndNumber.get(size);
                methodNameTokensNumberAndNumber.put(size,num+1);
            }
        }
        List<Map.Entry<Integer,Integer>>list =  Utils.sortMap_1(methodNameTokensNumberAndNumber);
        System.out.println(list);
    }

    private static void shortMethodNamesEva(String basePath) throws IOException {
//        String methodNameTokens = basePath + "MethodNameTokens.txt";
        String methodNameTokens = basePath + "parsedMethodNameTokens.txt";
//        String methodNameTokens = basePath + "TrainingData\\ParsedMethodNameTokens_1.txt";
        ArrayList<String> lines = ParserMethodNameMain.getLines(methodNameTokens);
        System.out.println(lines.size());
        HashMap<Integer,Integer> methodNameTokensNumberAndNumber = new HashMap<>();
        for(String line:lines){
            String [] splitArray = line.split(" ");
            int size = splitArray.length;
            if(methodNameTokensNumberAndNumber.get(size)==null){
                methodNameTokensNumberAndNumber.put(size,1);
            }
            else{
                int num = methodNameTokensNumberAndNumber.get(size);
                methodNameTokensNumberAndNumber.put(size,num+1);
            }
        }
        List<Map.Entry<Integer,Integer>>list =  Utils.sortMap_1(methodNameTokensNumberAndNumber);
        System.out.println(list);
    }

    public static String evaluate4adjustment(String basePath, String type, double threshold) throws IOException {
//        String result = basePath + type + "/predictedNames.txt";
//        String result = basePath + "/predictedNames.txt";
        String result = basePath + "/predictedNames_new.txt";
//        String labels = basePath + "/TestLabels.txt";
        String labels = basePath + "/TestLabels_new.txt";
//        String nameTokens = basePath + type + "\\parsedMethodNameTokens.txt";
//        String nameTokens = basePath + type + "/TestMethodNames.txt";
//        String nameTokens = basePath + "/TestMethodNames.txt";
        String nameTokens = basePath + "/TestMethodNames_new.txt";
//        String contextTokens = basePath + type + "/parsedMethodContextTokens.txt";
//        String contextTokens = basePath + "/parsedMethodContextTokens.txt";
        String contextTokens = basePath + "/parsedMethodContextTokens_new.txt";
        ArrayList<String> resultLines = ParserMethodNameMain.getLines(result);
        ArrayList<String> nameTokensLines = ParserMethodNameMain.getLines(nameTokens);
        ArrayList<String> contextTokensLines = ParserMethodNameMain.getLines(contextTokens);
        ArrayList<String> labelLines = ParserMethodNameMain.getLines(labels);

//        System.out.println(resultLines.size());
//        System.out.println(nameTokensLines.size());
        int c = 0;
        int ic =0;
        StringBuilder consb = new StringBuilder();
        StringBuilder inconsb = new StringBuilder();
        StringBuilder conContext = new StringBuilder();
        StringBuilder inconContext = new StringBuilder();
        if(type.equals("inconsistent")){
            for(int i=0;i<labelLines.size();i++){
//            for(int i=0;i<1432;i++){
                String label = labelLines.get(i);
                if(label.equals("0")){
                    String resultLine = resultLines.get(i);
//            System.out.println(resultLine);
                    String nameTokensLine = nameTokensLines.get(i);
                    String contextTokensLine = contextTokensLines.get(i);
//            System.out.println(nameTokensLine);
                    String [] splitArray1 = resultLine.split(" ");
                    String [] splitArray2 = nameTokensLine.split(" ");
                    List<String> resultArray = new ArrayList<>(Arrays.asList(splitArray1));
                    List<String> nameTokensArray = new ArrayList<>(Arrays.asList(splitArray2));
                    HashSet<String> resultSet = new HashSet<>(resultArray);
                    HashSet<String> nameTokenSet = new HashSet<>(nameTokensArray);
//            resultArray.retainAll(nameTokensArray);
                    resultSet.retainAll(nameTokenSet);
                    double sum = splitArray1.length + splitArray2.length;
                    double sum_div2 = sum / 2;
//            double sim = resultArray.size() / sum_div2;
                    double sim = resultSet.size() / sum_div2;
//            System.out.println(resultArray.size());
//            System.out.println(sum_div2);
//            System.out.println(sim);
                    if(sim>threshold){
//                System.out.println(i+":Consistent:"+resultLine+":"+nameTokensLine);
                        consb.append(resultLine+":"+nameTokensLine+"\n");
                        conContext.append(contextTokensLine+"\n");
                        c++;
                    }
                    else{
//                System.out.println(i+":Inconsistent:"+resultLine+":"+nameTokensLine);
                        inconsb.append(resultLine+":"+nameTokensLine+"\n");
                        inconContext.append(contextTokensLine+"\n");
                        ic++;
                    }
                }
                }

        }
        else if(type.equals("consistent")){
            for(int i=0;i<labelLines.size();i++){
//            for(int i=0;i<1432;i++){
                String label = labelLines.get(i);
                if(label.equals("1")){
                    String resultLine = resultLines.get(i);
//            System.out.println(resultLine);
                    String nameTokensLine = nameTokensLines.get(i);
                    String contextTokensLine = contextTokensLines.get(i);
//            System.out.println(nameTokensLine);
                    String [] splitArray1 = resultLine.split(" ");
                    String [] splitArray2 = nameTokensLine.split(" ");
                    List<String> resultArray = new ArrayList<>(Arrays.asList(splitArray1));
                    List<String> nameTokensArray = new ArrayList<>(Arrays.asList(splitArray2));
                    HashSet<String> resultSet = new HashSet<>(resultArray);
                    HashSet<String> nameTokenSet = new HashSet<>(nameTokensArray);
//            resultArray.retainAll(nameTokensArray);
                    resultSet.retainAll(nameTokenSet);
                    double sum = splitArray1.length + splitArray2.length;
                    double sum_div2 = sum / 2;
//            double sim = resultArray.size() / sum_div2;
                    double sim = resultSet.size() / sum_div2;
//            System.out.println(resultArray.size());
//            System.out.println(sum_div2);
//            System.out.println(sim);
                    if(sim>threshold){
//                System.out.println(i+":Consistent:"+resultLine+":"+nameTokensLine);
                        consb.append(resultLine+":"+nameTokensLine+"\n");
                        conContext.append(contextTokensLine+"\n");
                        c++;
                    }
                    else{
//                System.out.println(i+":Inconsistent:"+resultLine+":"+nameTokensLine);
                        inconsb.append(resultLine+":"+nameTokensLine+"\n");
                        inconContext.append(contextTokensLine+"\n");
                        ic++;
                    }
                }
                }

        }

//        if(type.equals("consistent")){
//            FileHelper.outputToFile(basePath + type + "\\correct.txt",consb,false);
//            FileHelper.outputToFile(basePath + type + "\\false.txt",inconsb,false);
//            FileHelper.outputToFile(basePath + type + "\\correctContext.txt",conContext,false);
//            FileHelper.outputToFile(basePath + type + "\\falseContext.txt",inconContext,false);
//        }
//        else{
//            FileHelper.outputToFile(basePath + type + "\\false.txt",consb,false);
//            FileHelper.outputToFile(basePath + type + "\\correct.txt",inconsb,false);
//            FileHelper.outputToFile(basePath + type + "\\falseContext.txt",conContext,false);
//            FileHelper.outputToFile(basePath + type + "\\correctContext.txt",inconContext,false);
//        }
        if(type.equals("consistent")){
//            System.out.println("TN:"+c);
//            System.out.println("FP:"+ic);
            return c+","+ic;
        }
        else {
//            System.out.println("TP:" + ic);
//            System.out.println("FN:" + c);
            return ic + "," + c;
        }


    }

    public static void evaluate_1(String basePath) throws IOException {
        String result = basePath + "/predictedNames.txt";
        String nameTokens = basePath + "/TestMethodNames.txt";
        String contextTokens = basePath  + "/parsedMethodContextTokens.txt";
        String labelsPath = basePath  + "/TestLabels.txt";
        ArrayList<String> resultLines = ParserMethodNameMain.getLines(result);
        ArrayList<String> nameTokensLines = ParserMethodNameMain.getLines(nameTokens);
        ArrayList<String> contextTokensLines = ParserMethodNameMain.getLines(contextTokens);
        ArrayList<String> labels = ParserMethodNameMain.getLines(labelsPath);

//        System.out.println(resultLines.size());
//        System.out.println(nameTokensLines.size());
        int TP = 0;
        int TN = 0;
        int FN = 0;
        int FP = 0;
        StringBuilder correctsb = new StringBuilder();
        StringBuilder incorrectsb = new StringBuilder();
        StringBuilder correctContext = new StringBuilder();
        StringBuilder incorrectContext = new StringBuilder();
        for(int i=0;i<resultLines.size();i++){
            String resultLine = resultLines.get(i);
//            System.out.println(resultLine);
            String nameTokensLine = nameTokensLines.get(i);
            String contextTokensLine = contextTokensLines.get(i);
            String label = labels.get(i);

//            System.out.println(nameTokensLine);
//            String [] splitArray1 = resultLine.split(" ");
//            String [] splitArray2 = nameTokensLine.split(" ");
//            List<String> resultArray = new ArrayList<>(Arrays.asList(splitArray1));
//            List<String> nameTokensArray = new ArrayList<>(Arrays.asList(splitArray2));
//            HashSet<String> resultSet = new HashSet<>(resultArray);
//            HashSet<String> nameTokenSet = new HashSet<>(nameTokensArray);
////            resultArray.retainAll(nameTokensArray);
//            resultSet.retainAll(nameTokenSet);
//            double sum = splitArray1.length + splitArray2.length;
//            double sum_div2 = sum / 2;
////            double sim = resultArray.size() / sum_div2;
//            double sim = resultSet.size() / sum_div2;
//            System.out.println(resultArray.size());
//            System.out.println(sum_div2);
//            System.out.println(sim);
            if(nameTokensLine.trim().equals(resultLine.trim())){
                if(label.equals("1")){
                    correctsb.append(resultLine+":"+nameTokensLine+"\n");
                    correctContext.append(contextTokensLine+"\n");
                    TN++;
                }
                else{
                    incorrectsb.append(resultLine+":"+nameTokensLine+"\n");
                    incorrectContext.append(contextTokensLine+"\n");
                    FN++;
                }
//                System.out.println(i+":Consistent:"+resultLine+":"+nameTokensLine);
            }
            else{
                if(label.equals("1")){
                    incorrectsb.append(resultLine+":"+nameTokensLine+"\n");
                    incorrectContext.append(contextTokensLine+"\n");
                    FP++;
                }
                else{
                    correctsb.append(resultLine+":"+nameTokensLine+"\n");
                    correctContext.append(contextTokensLine+"\n");
                    TP++;
                }
            }
        }
        System.out.println(TP);
        System.out.println(TN);
        System.out.println(FN);
        System.out.println(FP);

        FileHelper.outputToFile(basePath + "/evaluation/correctContext.txt",correctContext,false);
        FileHelper.outputToFile(basePath + "/evaluation/incorrectContext.txt",incorrectContext,false);
        FileHelper.outputToFile(basePath + "/evaluation/correctName.txt",correctsb,false);
        FileHelper.outputToFile(basePath + "/evaluation/incorrectName.txt",incorrectsb,false);

    }

    public static void evaluate(String basePath) throws IOException {
        String result = basePath + "/predictedNames.txt";
//        String result = basePath + "/predictedNames_INCON_RemainingC_Cross-Method.txt";
//        String result = basePath + "/predictedNames_CON_RemainingC_Cross-Method.txt";
//        String result = basePath + "/predictedNames_new2.txt";
        String nameTokens = basePath + "/evaluation/TestMethodNames.txt";
//        String nameTokens = basePath + "/TestMethodNames_new_INCON.txt";
//        String nameTokens = basePath + "/TestMethodNames_new_CON.txt";
//        String nameTokens = basePath + "/parsedMethodNameTokens_1432C.txt";
//        String nameTokens = basePath + "/TestMethodNames_new2.txt";
        String contextTokens = basePath  + "/evaluation/parsedMethodContextTokens.txt";
//        String contextTokens = basePath  + "/parsedMethodContextTokens_new_INCON.txt";
//        String contextTokens = basePath  + "/parsedMethodContextTokens_new_CON.txt";
//        String contextTokens = basePath  + "/parsedMethodContextTokens_1432C.txt";
//        String contextTokens = basePath  + "/parsedMethodContextTokens_new2.txt";
        String labelsPath = basePath  + "/TestLabels.txt";
//        String labelsPath = basePath  + "/TestLabels_new_INCON.txt";
//        String labelsPath = basePath  + "/TestLabels_new_CON.txt";
//        String labelsPath = basePath  + "/TestLabels_new2.txt";
        ArrayList<String> resultLines = ParserMethodNameMain.getLines(result);
        ArrayList<String> nameTokensLines = ParserMethodNameMain.getLines(nameTokens);
        ArrayList<String> contextTokensLines = ParserMethodNameMain.getLines(contextTokens);
        ArrayList<String> labels = ParserMethodNameMain.getLines(labelsPath);

//        System.out.println(resultLines.size());
//        System.out.println(nameTokensLines.size());
        int TP = 0;
        int TN = 0;
        int FN = 0;
        int FP = 0;
        StringBuilder correctsb = new StringBuilder();
        StringBuilder inconCorrectName = new StringBuilder();
        StringBuilder conCorrectName = new StringBuilder();
        StringBuilder incorrectsb = new StringBuilder();
        StringBuilder falsePositiveNames = new StringBuilder();
        StringBuilder correctContext = new StringBuilder();
        StringBuilder incorrectContext = new StringBuilder();
        StringBuilder Similarities = new StringBuilder();
        int cnt = 0;
        for(int i=0;i<resultLines.size();i++){
            String resultLine = resultLines.get(i);
//            System.out.println(resultLine);
            String nameTokensLine = nameTokensLines.get(i);
            String contextTokensLine = contextTokensLines.get(i);
            String label = labels.get(i);
//            System.out.println(nameTokensLine);
            String [] splitArray1 = resultLine.split(" ");
            String [] splitArray2 = nameTokensLine.split(" ");
            List<String> resultArray = new ArrayList<>(Arrays.asList(splitArray1));
            List<String> nameTokensArray = new ArrayList<>(Arrays.asList(splitArray2));
            HashSet<String> resultSet = new HashSet<>(resultArray);
            HashSet<String> nameTokenSet = new HashSet<>(nameTokensArray);
//            resultArray.retainAll(nameTokensArray);
            resultSet.retainAll(nameTokenSet);
            double sum = splitArray1.length + splitArray2.length;
            double sum_div2 = sum / 2;
//            double sim = resultArray.size() / sum_div2;
            double sim = resultSet.size() / sum_div2;
//            System.out.println(resultArray.size());
//            System.out.println(sum_div2);
//            System.out.println(sim);
            Similarities.append(sim+"\n");

            if(sim>0.99){
//            if(sim>0.49){
                if(label.equals("1")){
                    correctsb.append(i+":"+resultLine+":"+nameTokensLine+"\n");
                    correctContext.append(contextTokensLine+"\n");
                    conCorrectName.append(resultLine+":"+nameTokensLine+"\n");
                    TN++;
                }
                else{
                    incorrectsb.append(resultLine+":"+nameTokensLine+"\n");
                    incorrectContext.append(contextTokensLine+"\n");
                    FN++;
                }
//                System.out.println(i+":Consistent:"+resultLine+":"+nameTokensLine);
            }
            else{
                if(label.equals("1")){
                    if(sim==0) cnt++;
                    incorrectsb.append(resultLine+":"+nameTokensLine+"\n");
                    incorrectContext.append(contextTokensLine+"\n");
                    falsePositiveNames.append(resultLine+":"+nameTokensLine+":"+resultSet.size()+":"+sim+"\n");
                    FP++;
                }
                else{
                    correctsb.append(i+":"+resultLine+":"+nameTokensLine+"\n");
                    correctContext.append(contextTokensLine+"\n");
                    inconCorrectName.append(resultLine+":"+nameTokensLine+"\n");
                    TP++;
                }
            }
        }
        System.out.println(TP);
        System.out.println(TN);
        System.out.println(FN);
        System.out.println(FP);
        System.out.println(cnt);
//        FileHelper.outputToFile(basePath + "/evaluation/allCorrectContext.txt",correctContext,false);
//        FileHelper.outputToFile(basePath + "/evaluation/allIncorrectContext.txt",incorrectContext,false);
//        FileHelper.outputToFile(basePath + "/evaluation/allCorrectName.txt",correctsb,false);
//        FileHelper.outputToFile(basePath + "/evaluation/falsePositiveNames.txt",falsePositiveNames,false);
//        FileHelper.outputToFile(basePath + "/evaluation/allIncorrectName.txt",incorrectsb,false);
//        FileHelper.outputToFile(basePath + "/evaluation/InConCorrectName.txt",inconCorrectName,false);
//        FileHelper.outputToFile(basePath + "/evaluation/ConCorrectName.txt",conCorrectName,false);
//        FileHelper.outputToFile(basePath + "/evaluation/Similarities.txt",Similarities,false);

    }
    public static void evaluate(String basePath, String type) throws IOException {
        String result = basePath + type + "\\result.txt";
        String nameTokens = basePath + type + "\\parsedMethodNameTokens.txt";
        String contextTokens = basePath + type + "\\parsedMethodContextTokens.txt";
        ArrayList<String> resultLines = ParserMethodNameMain.getLines(result);
        ArrayList<String> nameTokensLines = ParserMethodNameMain.getLines(nameTokens);
        ArrayList<String> contextTokensLines = ParserMethodNameMain.getLines(contextTokens);

//        System.out.println(resultLines.size());
//        System.out.println(nameTokensLines.size());
        int c = 0;
        int ic =0;
        StringBuilder consb = new StringBuilder();
        StringBuilder inconsb = new StringBuilder();
        StringBuilder conContext = new StringBuilder();
        StringBuilder inconContext = new StringBuilder();
        for(int i=0;i<resultLines.size();i++){
            String resultLine = resultLines.get(i);
//            System.out.println(resultLine);
            String nameTokensLine = nameTokensLines.get(i);
            String contextTokensLine = contextTokensLines.get(i);
//            System.out.println(nameTokensLine);
            String [] splitArray1 = resultLine.split(" ");
            String [] splitArray2 = nameTokensLine.split(" ");
            List<String> resultArray = new ArrayList<>(Arrays.asList(splitArray1));
            List<String> nameTokensArray = new ArrayList<>(Arrays.asList(splitArray2));
            HashSet<String> resultSet = new HashSet<>(resultArray);
            HashSet<String> nameTokenSet = new HashSet<>(nameTokensArray);
//            resultArray.retainAll(nameTokensArray);
            resultSet.retainAll(nameTokenSet);
            double sum = splitArray1.length + splitArray2.length;
            double sum_div2 = sum / 2;
//            double sim = resultArray.size() / sum_div2;
            double sim = resultSet.size() / sum_div2;
//            System.out.println(resultArray.size());
//            System.out.println(sum_div2);
//            System.out.println(sim);
            if(sim>0.8){
//                System.out.println(i+":Consistent:"+resultLine+":"+nameTokensLine);
                consb.append(resultLine+":"+nameTokensLine+"\n");
                conContext.append(contextTokensLine+"\n");
                c++;
            }
            else{
//                System.out.println(i+":Inconsistent:"+resultLine+":"+nameTokensLine);
                inconsb.append(resultLine+":"+nameTokensLine+"\n");
                inconContext.append(contextTokensLine+"\n");
                ic++;
            }
        }
        if(type.equals("consistent")){
            System.out.println("TN:"+c);
            System.out.println("FP:"+ic);
        }
        else{
            System.out.println("TP:"+ic);
            System.out.println("FN:"+c);

        }

        if(type.equals("consistent")){
//            FileHelper.outputToFile(basePath + "correct.txt",consb,false);
//            FileHelper.outputToFile(basePath + "false.txt",inconsb,false);
            FileHelper.outputToFile(basePath + "correctContext.txt",conContext,false);
            FileHelper.outputToFile(basePath + "falseContext.txt",inconContext,false);
        }
        else{
//            FileHelper.outputToFile(basePath + "false.txt",consb,false);
//            FileHelper.outputToFile(basePath + "correct.txt",inconsb,false);
            FileHelper.outputToFile(basePath + "falseContext.txt",conContext,false);
            FileHelper.outputToFile(basePath + "correctContext.txt",inconContext,false);
        }
    }

    public static void evaluate_checkIfMatters(String basePath) throws IOException {
        String result = basePath + "result.txt";
        String nameTokens = basePath + "parsedMethodNameTokens_unique.txt";
        String contextTokens = basePath + "parsedMethodContextTokens_unique.txt";
        String icse2020keepFile = "E:\\BIT\\BadMethodName\\evaluation\\icse2020\\icse2020keep.txt";
        ArrayList<String> resultLines = ParserMethodNameMain.getLines(result);
        ArrayList<String> nameTokensLines = ParserMethodNameMain.getLines(nameTokens);
        ArrayList<String> contextTokensLines = ParserMethodNameMain.getLines(contextTokens);
        ArrayList<String> keepLines = ParserMethodNameMain.getLines(icse2020keepFile);
        Set<Integer> keepSet = new HashSet<>();
        for(String line:keepLines){
            int lineNumber = Integer.valueOf(line.split(" : ")[0]);
            keepSet.add(lineNumber);
        }
        System.out.println("keepSet.size()"+keepSet.size());
        Set<Integer> TPlineNumberSet = new HashSet<>();
        Set<Integer> FNlineNumberSet = new HashSet<>();
        Set<Integer> TNlineNumberSet = new HashSet<>();
        Set<Integer> FPlineNumberSet = new HashSet<>();

        System.out.println(resultLines.size());
        System.out.println(nameTokensLines.size());
        int c = 0;
        int ic =0;
        StringBuilder consb = new StringBuilder();
        StringBuilder inconsb = new StringBuilder();
        StringBuilder conContext = new StringBuilder();
        StringBuilder inconContext = new StringBuilder();
        for(int i=0;i<resultLines.size();i++){
            String resultLine = resultLines.get(i);
//            System.out.println(resultLine);
            String nameTokensLine = nameTokensLines.get(i);
            String contextTokensLine = contextTokensLines.get(i);
//            System.out.println(nameTokensLine);
            String [] splitArray1 = resultLine.split(" ");
            String [] splitArray2 = nameTokensLine.split(" ");
            List<String> resultArray = new ArrayList<>(Arrays.asList(splitArray1));
            List<String> nameTokensArray = new ArrayList<>(Arrays.asList(splitArray2));
            HashSet<String> resultSet = new HashSet<>(resultArray);
            HashSet<String> nameTokenSet = new HashSet<>(nameTokensArray);
//            resultArray.retainAll(nameTokensArray);
            resultSet.retainAll(nameTokenSet);
            double sum = splitArray1.length + splitArray2.length;
            double sum_div2 = sum / 2;
//            double sim = resultArray.size() / sum_div2;
            double sim = resultSet.size() / sum_div2;
//            System.out.println(resultArray.size());
//            System.out.println(sum_div2);
            System.out.println(sim);
            if(sim>0.94){
                System.out.println(i+":Consistent:"+resultLine+":"+nameTokensLine);
                consb.append(resultLine+":"+nameTokensLine+"\n");
                conContext.append(contextTokensLine+"\n");
                c++;
                FNlineNumberSet.add(i);
            }
            else{
                System.out.println(i+":Inconsistent:"+resultLine+":"+nameTokensLine);
                inconsb.append(resultLine+":"+nameTokensLine+"\n");
                inconContext.append(contextTokensLine+"\n");
                ic++;
                TPlineNumberSet.add(i);
            }
        }
        System.out.println("c:"+c);
        System.out.println("ic:"+ic);
//        FileHelper.outputToFile(basePath + "correct.txt",consb,false);
//        FileHelper.outputToFile(basePath + "false.txt",inconsb,false);
//        FileHelper.outputToFile(basePath + "falseContext_1.txt",conContext,false);
//        FileHelper.outputToFile(basePath + "correctContext_1.txt",inconContext,false);
//
//        FileHelper.outputToFile(basePath + "false_1.txt",consb,false);
//        FileHelper.outputToFile(basePath + "correct_1.txt",inconsb,false);
        System.out.println(TPlineNumberSet.size());
        System.out.println(FNlineNumberSet.size());
        int TP=0,FN=0;
        for(int lineNumber : TPlineNumberSet) {
            if (keepSet.contains(lineNumber)) {
                TP++;
            }
        }
        for(int lineNumber:FNlineNumberSet){
            if(keepSet.contains(lineNumber)){
                FN++;
            }
        }
        System.out.println(TP+":"+FN);
    }

}
